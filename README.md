We divided our project into a set of linked c files with their respective header fields.  These files include build_spec.c/build_spec.h, command.c/command.h, graph.c/graph.h, list.c/list.h, main.c/main.h, parser.c/parser.h, and tools.c/tools.h.

The program defines build_t, a structure holding a character pointer to a target, linked list pointers to dependencies and commands, and two integers which check the validity of the build. Build_spec.c defines some helper functions to initialize a buld_t structure and add dependencies and commands, while tools.c defines a malloc wrapper function which build_spec uses to allocate memory.  In addition, list_t, defined as a list of build_t structures, is initialized within list.c, and parser.c is responsible for reading in the input from a text file and returing a list of valid builds. Parser.c defines local functions to get the index of the target of a build as well as return the new line in a build which is returned when valid, iterated if pointer points to empty line, or returns NULL is file reaches the end of stream.

From here, the program creates a graph from the list and sets the head and vertices heads to a legitimate targets and dependencies respectively.  Finally, once our valid graph is built, we call the privately defined function tryVertexRun in main.c to run the commands using the make dependency rules.

An interesting facet of this project is using a generic list with data of type void*. Freeing data systematically from this data type became more difficult as more than one type of data (i.e. build_t, char*, vertex_t) were occupying the data field of our linked list node. By providing a free function pointer specific to each data type, we were able to sytematically free all data inside of a linked list.
